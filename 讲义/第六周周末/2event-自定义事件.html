<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
<style type="text/css">
div{ width:100px; height:100px; position:absolute; top:100px; left:100px; background:red; cursor:move; -webkit-user-select:none;}
</style>
</head>

<body>
<div id="div1"></div>
<div id="div2" style="left:300px; background:blue;"></div>
<div id="div3" style="top:300px; background:green;"></div>
</body>
</html>
<script>
//bind,unbind//this
//on,off,run;//顺序问题
function  on(ele,type,fn){//把需要绑定的方法保存到程序池（数组）
	if(/^self/.test(type)){//处理自定义事件
		if(!ele["aSelf"+type])ele["aSelf"+type]=[];
		var a=ele["aSelf"+type];
		for(var i=0;i<a.length;i++){
			if(a[i]==fn)return;	
		}
		a.push(fn);
		return;
	}
	
	if(ele.addEventListener){
		ele.addEventListener(type,fn,false);
		return;	
	}
	if(!ele["aEvent"+type]){
		ele.attachEvent("on"+type,processThis(run,ele));
		ele["aEvent"+type]=[];
		ele.aEventclick
	}
	var a=ele["aEvent"+type];
	
	for(var i=0;i<a.length;i++){
		if(a[i]==fn)return;//避免重复绑定此方法	
	}
	
	a.push(fn);//核心代码
	//系统事件和自定义程序池里的方法如何关联：
	
	
	
	
}
function run(){//这是真正被绑定到事件上的方法，当事件触发时候，执行这run方法，由run方法按顺序遍历执行保存到程序池里的方法
	var e=window.event;
	var type=e.type;
	var a=this["aEvent"+type];//这个数组是从那儿来的
	if(!e.target){
		e.target=e.srcElement;
		e.stopPropagation=function(){e.cancelBubble=true;}
		e.preventDefault=function(){e.returnValue=false;}
		e.pageX=(document.documentElement.scrollLeft||document.body.scrollLeft)+e.clientX;
		e.pageY=(document.documentElement.scrollTop||document.body.scrollTop)+e.clientY;
			
	}
	if(a){
		for(var i=0;i<a.length;i++){//核心代码
			if(typeof a[i] == "function"){
				a[i].call(this,e);	
			}else{
				a.splice(i,1);
				i--;	
			}
		}
	}
	
}

function selfRun(type,e){//type是指的自定义的事件类型，e是系统的事件对象
	var a=this["aSelf"+type];
	if(a){
		for(var i=0;i<a.length;i++){
			if(typeof a[i]=="function"){
				a[i].call(this,e);
			}else{
				a.splice(i,1);
				i--;
			}
		}
	}
}


function off(ele,type,fn){//是和on方法相反的方法，它负责从程序池里把指定fn方法移除
	if(ele.removeEventListener){
		ele.removeEventListener(type,fn,false);
		return;	
	}
	var a=ele["aEvent"+type];
	if(a){
		for(var i=0;i<a.length;i++){
			if(a[i]==fn){
				a[i]=null;
				return;
			}
		}
	}
	
}
function processThis(fn,obj){
	return function(e){fn.call(obj,e);}	
}

function down(e){
	this.x=this.offsetLeft;
	this.y=this.offsetTop;//保存盒子的起始坐标
	this.mx=e.pageX;
	this.my=e.pageY;//保存鼠标的起始坐标
	
	if(this.setCapture){
		this.setCapture();//专门处理mousemove事件，防止元素丢失鼠标	
		on(this,"mousemove",move);
		on(this,"mouseup",up);
	}else{
		//Function.prototype.bind;
		this.MOVE=move.bind(this);
		this.UP=up.bind(this);
		on(document,"mousemove",this.MOVE);//this指向当前被拖拽的元素
		on(document,"mouseup",this.UP);
	}
	e.preventDefault();	
	//selfRun("selfdragstart",e);//发布，通知
	selfRun.call(this,"selfdragstart",e);
	//on(div1,"selfdragstart",clearEffect);
	
}
function move(e){
	this.style.left=e.pageX-this.mx+this.x+"px";
	this.style.top=e.pageY-this.my+this.y+"px";
	
	
	selfRun.call(this,"selfdragging",e);
}
function up(e){
	if(this.releaseCapture){
		this.releaseCapture();
		off(this,"mousemove",move);
		off(this,"mouseup",up);
	}else{
		off(document,"mousemove",this.MOVE);
		off(document,"mouseup",this.UP);	
	}
	selfRun.call(this,"selfdragend",e);
}

on(div1,"mousedown",down);
on(div2,"mousedown",down);
on(div3,"mousedown",down);

function clearEffect(){
	clearTimeout(this.flyTimer);
	clearTimeout(this.dropTimer);	
}

function getSpeed(e){
	if(this.prevPosi){
		this.flySpeed=e.pageX-this.prevPosi;
		this.prevPosi=e.pageX;
	}else{
		this.prevPosi=e.pageX;	
	}
}

function fly(){
		this.flySpeed*=.98;
		var current=this.offsetLeft+this.flySpeed;//正常情况下本次运动到达的位置
		var r=(document.documentElement.clientWidth||document.body.clientWidth)-this.offsetWidth;
		if(current<=0){
			this.style.left=0;
			this.flySpeed*=-1;//折返	
		}else if(current>=r){
			this.style.left=r+"px";
			this.flySpeed*=-1;	
		}else{
			this.style.left=this.offsetLeft+this.flySpeed+"px";
		}
		if(Math.abs(this.flySpeed)>=0.5)
			this.flyTimer=window.setTimeout(processThis(fly,this),20);
};
function drop(){
	if(this.dropSpeed){
		this.dropSpeed+=9.8;	
	}else{
		this.dropSpeed=9.8
	}
	
	var bottom=(document.documentElement.clientHeight||document.body.clientHeight)-this.offsetHeight;
	this.dropSpeed*=.98;
	var current=this.offsetTop+this.dropSpeed;
	if(current>=bottom){
		this.style.top=bottom+"px";
		this.dropSpeed*=-1;	
		this.flag++;//如果撞到边界，则让flag累加
		//this.flag是用来判断盒子是否连续到达边界的依据
		//什么时候flag会大2
	}else{
		this.style.top=current+"px";
		this.flag=0;//如果是正常运行，则让flag归0
	}
	if(this.flag<2)
		this.dropTimer=window.setTimeout(processThis(drop,this),20);
	
}
//1、完成了一个很完整的拖拽的效果
//2、通过修改move，实现了计算this.flySpeed的值
//3、通过修改up方法，实现了在拖拽结束的时候的两个动画效果
//4、通过修改down方法，实现了清除动画效果的积累问题

//当拖拽开始的时候，清除积累的fly和drop的效果
//当拖拽进行的时候，计算出速度来
//当拖拽结束的时候，fly&&drop

/*
on(div1,"标识着拖拽开始的标识符",clearEffect);
on(div1,"click",animate);//click只是个标识符，它标识的是鼠标点一下的那个行为。具体的操作上：是以click字符串为区分符，构造一个数组，把animate保存到了这个数组里
ele.aEventclick=[];
ele.aEventclick.push(animate);

通知：

对应到某个数组（以事件类型或以事件标识符来对应到某个数组）

run(type){
	var a=this["aEvent"+type];
	for(var i=0;i<a.length;i++){
		a[i].call(this,e);	
		a[i]();
	}
}


sing{
	
	
	run("sing");
}

marry{
	run("marry");
}

play{
	
}


dragstart{
	run("");	
}
ele.addEventListener("click",fn);

EventTarget --->run

click{
	
	run("click");//当run执行的时候，这会的"click"是规定好的事件规范	
	
}


on(div1,"标识着拖拽进行的标识符",getSpeed);

on(div1,"标识着拖拽结束的标识符",fly);
on(div1,"标识着拖拽结束的标识符",drop);*/

on(div1,"selfdragstart",clearEffect);

on(div1,"selfdragging",getSpeed);

on(div1,"selfdragend",fly);
on(div1,"selfdragend",drop);

//加拖拽限定（拖拽范围，0-1000）
//当开始拖拽的时候加个虚线边框，结束拖拽的时候去掉边框

function dragRange(){
	if(this.offsetLeft>=1000){
		this.style.left=1000+"px";	
	}else if(this.offsetLeft<=0){
		this.style.left=0;	
	}
}
function addBorder(){
	this.style.border="2px dashed black";
}
function removeBorder(){
	this.style.border="none";
	}
on(div1,"selfdragging",dragRange);
on(div1,"selfdragstart",addBorder);
on(div1,"selfdragend",removeBorder);



</script>
