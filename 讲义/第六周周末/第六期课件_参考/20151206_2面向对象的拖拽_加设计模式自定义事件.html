<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>无标题文档</title>
<style type="text/css">
#div1{ width:100px; height:100px; background:red; position:absolute; top:0; left:0; cursor:move;}
</style>
</head>

<body>
<div id="div1"></div>
为什么要用面向对象
面向对象是世界观，也是方法论
看待程序的方式：
拖拽：看成一个动作，一个行为
//不仅是行为，还是承载这个行为的载体
面向对象：以对象类型的数据（就是以这种复合的数据类型，它可以承载很多的属性或方法）以导向的编程方式
把有共同的特征的数据，进行抽象，形成一个类，然后通过这个类，对有共性的东西进行管理

</body>
</html>
<script src="event.js"></script>
<script>
//如果定义一个Drag,在这个类的实例上，承载拖拽的这个行为
//着重的关注两点：它是如何承载行为的，它是如何进行管理的

function processThis(obj,fn){//fn.bind
	return function (e){fn.call(obj,e)}	
}

function EventEmitter(){};
EventEmitter.prototype.on=function(type,fn){
	if(!this[type]){
		this[type]=[];	
	}
	var a=this[type];
	for(var i=0;i<a.length;i++){
		if(a[i]==fn)return ;	
	}
	a.push(fn);
	
}
EventEmitter.prototype.run=function(type,e){
	var a=this[type];
	if(a){
		for(var i=0;i<a.length;i++){
			if(typeof a[i]=="function"){
				a[i].call(this,e);	
			}else{
				a.splice(i,1);
				i--;	
			}
		}
	}
}
EventEmitter.prototype.off=function(type,fn){
	var a=this[type];
	if(a){
		for(var i=0;i<a.length;i++){
			if(a[i]==fn){
				a[i]=null;
				break;	
			}
		}
	}
}


function Drag(ele){//构造函数，ele表示被拖拽的元素
	this.ele=ele;//把要拖拽的元素保存在当前实例的属性ele上,以便于Drag类的其它方法也可以操作这个被拖拽的元素ele
	this.x=null;//表示把这个属性提前准备好
	this.y=null;
	this.mx=null;
	this.my=null;
	
	//function processThis(obj,fn){return function (e){fn.call(obj,e)}	}
	this.DOWN=processThis(this,this.down);
	this.MOVE=processThis(this,this.move);
	this.UP=processThis(this,this.up);
	//on(ele,"mousedown",this.down);//this.down,this.down();
	on(ele,"mousedown",this.DOWN);//事件里的this的原则是：这个方法绑定给谁，当这个方法在执行的时候，this就是谁
	//面向对象的原则是：类上的方法里的this指向的当前实例
	//我们现在的原则是采用面向对象的this的原则：这个类上方法里所有的this都是指的当前类的实例，如果出现的偏差，则用processThis方法解决
}
Drag.prototype=new EventEmitter;
//Drag.prototype.__proto__=EventEmitter.prototype;
Drag.prototype.down=function(e){
	this.x=this.ele.offsetLeft;
	this.y=this.ele.offsetTop;
	this.mx=e.pageX;
	this.my=e.pageY;
	
	if(this.ele.setCapture){
		this.ele.setCapture();
		on(this.ele,"mousemove",this.MOVE);
		on(this.ele,"mouseup",this.UP);
	}else{
		on(document,"mousemove",this.MOVE);
		on(document,"mouseup",this.UP);
	}
	e.preventDefault();
	this.run("dragstart",e);
}
Drag.prototype.move=function(e){
	this.ele.style.left=this.x+(e.pageX-this.mx)+"px";
	this.ele.style.top=this.y+(e.pageY-this.my)+"px";
	//控制的还是dom元素
	this.run("drag",e);
}

Drag.prototype.up=function(e){
	if(this.ele.releaseCapture){
		this.ele.releaseCapture();
		off(this.ele,"mousemove",this.MOVE);
		off(this.ele,"mouseup",this.UP);
	}else{
		off(document,"mousemove",this.MOVE);
		off(document,"mouseup",this.UP);
	}
	this.run("dragend",e);
}
Drag.prototype.addBorder=function(){
	this.ele.style.border="2px green dashed";	
	
}
Drag.prototype.removeBorder=function(){
	this.ele.style.border="";	
}
Drag.prototype.border=function(){
	this.on("dragstart",this.addBorder);
	this.on("dragend",this.removeBorder);	
}
var obj=new Drag(div1);
/*obj.limit({left:100,right:500,top:0,bottom:400});//
obj.addBorder();//*/
obj.border();
obj.on("dragstart",clearEffect);
obj.on("drag",getSpeed);
obj.on("dragend",fly);
obj.on("dragend",drop);


function clearEffect(){
	window.clearTimeout(this.flyTimer);
	window.clearTimeout(this.dropTimer);	
}
function getSpeed(e){//通过两次mousemove事件之间鼠标产生的距离，计算出速度
	if(!this.prevPosi){
		this.prevPosi=e.pageX;	
	}else{
		this.speed=e.pageX-this.prevPosi;
		this.prevPosi=e.pageX;
	}
}

function fly(){
	this.speed*=.97;
	var val=this.ele.offsetLeft+this.speed;	//计算下一次的位置
	var maxRight=document.documentElement.clientWidth-this.ele.offsetWidth;//计算右边界
	if(val>=maxRight){//右边不能过界
		this.ele.style.left=maxRight+"px";
		this.speed*=-1;	//让方向调头
	}else if(val<=0){//左边也不能过界
		this.ele.style.left=0;
		this.speed*=-1;	
	}else{//正常的运动
		this.ele.style.left=val+"px";	
	}
	//100.4 = 100
	if(Math.abs(this.speed)>=0.5){
		this.flyTimer=window.setTimeout(processThis(this,fly),20);	
	}
}
var counter=0;
function drop(){
	if(!this.dropSpeed){
		this.dropSpeed=9;	
	}else{
		this.dropSpeed+=9;	
	}
	this.dropSpeed*=.97;
	var val=this.ele.offsetTop+this.dropSpeed;
	var maxBottom=document.documentElement.clientHeight-this.ele.offsetHeight;
	if(val>=maxBottom){
		this.ele.style.top=maxBottom+"px";
		this.dropSpeed*=-1;
		counter++	
	}else{
		this.ele.style.top=val+"px";
		counter=0;	
	}
	if(counter<2){
		this.dropTimer=window.setTimeout(processThis(this,drop),20);	
	}
}


</script>
